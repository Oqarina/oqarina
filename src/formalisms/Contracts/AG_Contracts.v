(***
 * Oqarina
 * Copyright 2021 Carnegie Mellon University.
 *
 * NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
 * INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
 * UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR
 * IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF
 * FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS
 * OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT
 * MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT,
 * TRADEMARK, OR COPYRIGHT INFRINGEMENT.
 *
 * Released under a BSD (SEI)-style license, please see license.txt or
 * contact permission@sei.cmu.edu for full terms.
 *
 * [DISTRIBUTION STATEMENT A] This material has been approved for public
 * release and unlimited distribution.  Please see Copyright notice for
 * non-US Government use and distribution.
 *
 * This Software includes and/or makes use of the following Third-Party
 * Software subject to its own license:
 *
 * 1. Coq theorem prover (https://github.com/coq/coq/blob/master/LICENSE)
 * Copyright 2021 INRIA.
 *
 * 2. Coq JSON (https://github.com/liyishuai/coq-json/blob/comrade/LICENSE)
 * Copyright 2021 Yishuai Li.
 *
 * DM21-0762
***)

(*| .. coq:: none |*)
Require Import Coq.Relations.Relation_Definitions.
Require Export Coq.Classes.RelationClasses.
Require Export Coq.Classes.Morphisms.
Require Import Coq.Classes.DecidableClass.
Require Import Coq.Lists.List.
Import ListNotations. (* from List *)

Require Import Coq.Bool.Bool.
Require Import Coq.Classes.SetoidClass.
Open Scope equiv_scope.
Require Import Coq.Sorting.Permutation.
Require Import Coq.Logic.Decidable.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import Coq.Logic.PropExtensionality.
Set Implicit Arguments.
Set Strict Implicit.

Require Import Oqarina.CoqExt.all.
Require Import Oqarina.formalisms.Contracts.Specification.
Require Import Oqarina.formalisms.Contracts.MetaTheory.

Section Assume_Guarantee_Contracts.
(*| .. coq:: |*)

(*|

A/G Contracts
=============

In this section, we define the notion of Assume/Guarantee contracts (or A/G contract). A :coq:`AG_Contract` refines the notion of contract from the meta-theory to components.

Without loss of generality, we define a component as a set of variables (:coq:`V`) that validates a specific assertion, i.e. a function whose signature is :coq:`list V -> Prop`. For instance, the set of static configuration parameters of a component, or a trace generated by some behavioral description.

For an A/G contract, an assumption (A) states assumptions made on the environment by a model and a guarantee (G) states guarantees offered by a model. They are both assertions on the same set of variables.

A/G contracts trivially meet all the meta-theory lemmas proved above.
We only prove a subset of them. Proofs follow the same schema: we map
an A/G contract to a general contract and conclude.

|*)

Import Contract_Notations.

Variable V : Type.
Context `{spec : Specification V}.

Definition Assertion: Type := V -> Prop.
Definition Component := Assertion.
Definition Environment := Assertion.

Record AG_Contract := {
    A: Assertion ;
    G: Assertion ;
}.

Definition AG_Contract_to_Contract (AG : AG_Contract) := {|
    Ec := AG.(A) ;
    Mc := AG.(G) ;
|}.

Notation "@ c" := (AG_Contract_to_Contract c)
    (at level 70 , no associativity).

(*| A saturated contract is an A/G contract defines by the following rule predicate. It is an idemptotent function. |*)

Definition Saturate (AG : AG_Contract) := {|
    A := AG.(A);
    G := fun x => (AG.(A) x -> AG.(G) x);
|}.

Lemma Saturate_idempotent: forall ag,
    (@Saturate ag) == (@ Saturate (Saturate ag)).
Proof.
    intros.
    unfold AG_Contract_to_Contract.
    simpl.

    assert (
        (fun x => A ag x -> G ag x) =
        (fun x => A ag x -> A ag x -> G ag x)
    ).
    apply functional_extensionality. intros.
    apply propositional_extensionality.
    firstorder.

    rewrite H. reflexivity.
Qed.

(*| A saturated contract is equivalent to the original contract if
the environment is compatible with the contract.

Note: :cite:`benvenisteContractsSystemsDesign`, p36 introduces this lemma without proof. It misses the hypothesis on the environment. |*)

Lemma Saturate_equiv: forall ag,
    (forall v, v ⊢e (@ ag)) ->
        (@ Saturate ag) == (@ ag).
Proof.
    intros. unfold Saturate.
    unfold AG_Contract_to_Contract.
    simpl. firstorder.
Qed.

(*| The notion of contract refinement and composition is directly inherited from the meta-theory.

We demonstrate that a saturated contract preserves some initial properties, e.g. equivalence, compatibility, etc. |*)

Theorem contract_extensionality : forall (c1 c2 : AG_Contract),
    (@c1) == (@c2) -> Saturate c1 = Saturate c2.
Proof.
    simpl.
    intros. firstorder.
    unfold refines in *.
    simpl in *.
    unfold Saturate.

    assert (
        (fun x : V => A c1 x -> G c1 x) =
        (fun x : V => A c2 x -> G c2 x)
    ).
    apply functional_extensionality. intros.
    specialize (H x).
    specialize (H0 x).
    apply propositional_extensionality. firstorder.

    assert (forall m, A c1 m = A c2 m).
    intros.
    specialize (H m).
    specialize (H0 m).
    apply propositional_extensionality. firstorder.

    assert (A c1 = A c2).
    apply functional_extensionality. apply H2.

    rewrite H1. rewrite H3. reflexivity.
Qed.

Lemma implements_implements_saturate: forall c v,
    v ⊢m (@c) -> v ⊢m (@(Saturate c)).
Proof.
    simpl. firstorder.
Qed.

Lemma implements_saturate_implements: forall c v,
    (forall v, v ⊢e (@ c)) ->
        v ⊢m (@(Saturate c)) -> v ⊢m (@c).
Proof.
    simpl. firstorder.
Qed.

(*| .. coq:: none |*)
End Assume_Guarantee_Contracts.
(*| .. coq:: |*)
