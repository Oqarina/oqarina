package arincexample1
public

	with ARINC653;

	data integer
	end integer;

	data ordercmd
	end ordercmd;

	data protected_data
		properties
			Concurrency_Control_Protocol => Protected_Access;
	end protected_data;

	-- Now, declare the virtual processors that model
	-- partition runtime.
	virtual processor partition1_rt
		properties
			Scheduling_Protocol => (RMS);
	end partition1_rt;

	virtual processor implementation partition1_rt.impl
	end partition1_rt.impl;

	virtual processor partition2_rt
		properties
			Scheduling_Protocol => (RMS);
	end partition2_rt;

	virtual processor implementation partition2_rt.impl
	end partition2_rt.impl;

	subprogram sensor_temperature_spg
	end sensor_temperature_spg;

	subprogram sensor_receiveinput_spg
	end sensor_receiveinput_spg;

	subprogram commandboard_receiveinput_spg
	end commandboard_receiveinput_spg;

	subprogram commandboard_printinfos_spg
	end commandboard_printinfos_spg;

	-- Threads for the first partition
	thread sensor_temperature_thread
		features
			tempout: out data port integer;
			order: in event data port ordercmd;
		properties
			Initialize_Entrypoint => classifier (arincexample1::sensor_temperature_spg);
			Priority => 42;
			Stack_Size => 100 Kbyte;
			Period => 20ms;
			Compute_Execution_Time => 10ms .. 12ms;
			Deadline => 40ms;
	end sensor_temperature_thread;

	thread implementation sensor_temperature_thread.impl
	end sensor_temperature_thread.impl;

	thread sensor_receiveinput_thread
		features
			commandin: in event data port integer;
			order: out event data port ordercmd;
		properties
			Initialize_Entrypoint => classifier (arincexample1::sensor_receiveinput_spg);
			Priority => 10;
			Stack_Size => 100 Kbyte;
			Period => 20ms;
			Compute_Execution_Time => 8ms .. 10ms;
			Deadline => 40ms;
	end sensor_receiveinput_thread;

	thread implementation sensor_receiveinput_thread.impl
	end sensor_receiveinput_thread.impl;

	--  Threads for the second partition
	thread commandboard_receiveinput_thread
		features
			temp: in data port integer;
			tempavg: requires data access integer {ARINC653::Queueing_Discipline => FIFO;};
			newavg: out event port;
			need_semaphore: requires data access protected_data {ARINC653::Queueing_Discipline => FIFO;};
		properties
			Initialize_Entrypoint => classifier (arincexample1::commandboard_receiveinput_spg);
			Priority => 42;
			Stack_Size => 100 Kbyte;
			Period => 20ms;
			ARINC653::Time_Capacity => 7ms;
			Compute_Execution_Time => 5ms .. 7ms;
			Deadline => 40ms;
	end commandboard_receiveinput_thread;

	thread commandboard_printinfos_thread
		features
			ordersensor: out event data port integer;
			tempavg: requires data access integer {ARINC653::Queueing_Discipline => FIFO;};
			newavg: in event port;
			need_semaphore: requires data access protected_data {ARINC653::Queueing_Discipline => FIFO;};
		properties
			Initialize_Entrypoint => classifier (arincexample1::commandboard_printinfos_spg);
			Priority => 43;
			Stack_Size => 100 Kbyte;
			Period => 20ms;
			ARINC653::Time_Capacity => 6ms;
			Compute_Execution_Time => 2ms .. 6ms;
			Deadline => 40ms;
	end commandboard_printinfos_thread;

	-- Now, declare process that model partition address space
	process partition1_process
		features
			queueingin: in event data port integer {Queue_Size => 4;
				ARINC653::Timeout => 5ms;
				ARINC653::Queueing_Discipline => FIFO;};
			samplingout: out data port integer;
	end partition1_process;

	process implementation partition1_process.impl
		subcomponents
			temperature: thread sensor_temperature_thread.impl;
			order: thread sensor_receiveinput_thread.impl;
		connections
			bufferconnectionexample: port order.order -> temperature.order;
			c1: port queueingin -> order.commandin;
			c2: port temperature.tempout -> samplingout;
	end partition1_process.impl;

	process partition2_process
		features
			queueingout: out event data port integer {ARINC653::Timeout => 10ms;};
			--  In the context of a event data port, the ARINC653::Timeout property
			--  is the timeout we used in the APEX functions. 
	
			samplingin: in data port integer {ARINC653::Sampling_Refresh_Period => 10ms;};
			--  The ARINC653::Sampling_Refresh_Period apply only to in data port. It is the refresh
			--  period for sampling ports.
	end partition2_process;

	process implementation partition2_process.impl
		subcomponents
			receiver: thread commandboard_receiveinput_thread;
			printer: thread commandboard_printinfos_thread;
			sem: data protected_data;
			blackboard: data integer;
		connections
			--  example of intra-partition communication with data ports (blackboards)
			blackboardconnection1: data access blackboard -> printer.tempavg;
			blackboardconnection2: data access blackboard -> receiver.tempavg;
			--  example of intra-partition communication with event port (events)
			eventconnectionexample: port receiver.newavg -> printer.newavg;
			c0: port printer.ordersensor -> queueingout;
			c1: port samplingin -> receiver.temp;
			c2: data access sem -> receiver.need_semaphore {ARINC653::Timeout => 20ms;};
			c3: data access sem -> printer.need_semaphore {ARINC653::Timeout => 10ms;};
	end partition2_process.impl;

	-- Main runtime
	processor powerpc
	end powerpc;

	processor implementation powerpc.impl
		subcomponents
			part1: virtual processor partition1_rt.impl;
			part2: virtual processor partition2_rt.impl;
		properties
			ARINC653::Module_Major_Frame => 50ms;

			ARINC653::Module_Schedule => ([Partition => reference (part1);
					Duration => 10ms;
					Periodic_Processing_Start => false;],
				[Partition => reference (part2);
					Duration => 10ms;
					Periodic_Processing_Start => false;],
				[Partition => reference (part1);
					Duration => 30ms;
					Periodic_Processing_Start => false;]
			);
	end powerpc.impl;

	-- Memory
	memory partition1_memory
		properties
			Base_Address => 0;
			ARINC653::Memory_Kind => (Memory_Code);
	end partition1_memory;

	memory partition2_memory
		properties
			Base_Address => 100;
			ARINC653::Memory_Kind => (Memory_Code);
	end partition2_memory;

	memory main_memory
	end main_memory;

	memory implementation main_memory.impl
		subcomponents
			part1mem: memory partition1_memory;
			part2mem: memory partition2_memory;
	end main_memory.impl;

	system arincsystem
	end arincsystem;

	system implementation arincsystem.impl
		subcomponents
			mem: memory main_memory.impl;
			cpu: processor powerpc.impl;
			partition1_pr: process partition1_process.impl;
			partition2_pr: process partition2_process.impl;
		connections
			samplingconnection: port partition1_pr.samplingout -> partition2_pr.samplingin;
			queueingconnection: port partition2_pr.queueingout -> partition1_pr.queueingin;
		properties
			--  bind partition process to their associated       
			--  runtime (virtual processor)
			Actual_Processor_Binding => (reference (cpu.part1)) applies to partition1_pr;
			Actual_Processor_Binding => (reference (cpu.part2)) applies to partition2_pr;

			--  bind partition process to their address spaces       
			--  (memory components)
			Actual_Memory_Binding => (reference (mem.part1mem)) applies to partition1_pr;
			Actual_Memory_Binding => (reference (mem.part2mem)) applies to partition2_pr;
	end arincsystem.impl;


-------------------------

	system CPU	end CPU;

	system implementation CPU.Two_Cores
		subcomponents
			core1: processor powerpc;
			core2: processor powerpc;
	end CPU.Two_Cores;

	system implementation arincsystem.impl_multicore
		subcomponents
			mem: memory main_memory.impl;
			cpus: system CPU.Two_Cores;
			
			partition1_pr: process partition1_process.impl;
			partition2_pr: process partition2_process.impl;
			
			part1: virtual processor partition1_rt.impl;
			part2: virtual processor partition2_rt.impl;
			
		connections
			samplingconnection: port partition1_pr.samplingout -> partition2_pr.samplingin;
			queueingconnection: port partition2_pr.queueingout -> partition1_pr.queueingin;
		properties
			--  bind partition process to their associated       
			--  runtime (virtual processor)
			Actual_Processor_Binding => (reference (part1)) applies to partition1_pr;
			Actual_Processor_Binding => (reference (part2)) applies to partition2_pr;

			--  bind runtimes to separate cores
			Actual_Processor_Binding => (reference (cpus.core1)) applies to part1;
			Actual_Processor_Binding => (reference (cpus.core1)) applies to part2;

			--  bind partition process to their address spaces       
			--  (memory components)
			Actual_Memory_Binding => (reference (mem.part1mem)) applies to partition1_pr;
			Actual_Memory_Binding => (reference (mem.part2mem)) applies to partition2_pr;
	end arincsystem.impl_multicore;


end arincexample1;